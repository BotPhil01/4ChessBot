/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BOARDDIMENSION = 14;\nwindow.onload = function () {\n    buttons();\n};\nfunction buttons() {\n    var h = document.getElementById(\"homeSwap\");\n    if (h) {\n        h.onclick = swap;\n    }\n    var bb = document.getElementById(\"boardBackButton\");\n    if (bb) {\n        bb.onclick = swap;\n    }\n    var db = document.getElementById(\"debugButton\");\n    var draggable = document.getElementById(\"draggable\");\n    if (draggable) {\n        dragPieceElement(draggable);\n    }\n}\n// func for swapping between home and game pages\nfunction swap() {\n    let gameDiv = document.getElementById(\"gameDiv\");\n    let homeDiv = document.getElementById(\"homeDiv\");\n    // mandatory error handling by ts\n    if (!homeDiv || !gameDiv) {\n        console.error(\"No divs founds\");\n        return;\n    }\n    if (homeDiv.getAttribute(\"class\") == \"centered\" && gameDiv.getAttribute(\"class\") == \"destroy\") {\n        homeDiv.setAttribute(\"class\", \"destroy\");\n        gameDiv.setAttribute(\"class\", \"block\");\n        initBoard();\n    }\n    else {\n        homeDiv.setAttribute(\"class\", \"centered\");\n        gameDiv.setAttribute(\"class\", \"destroy\");\n    }\n}\n// func for dragging pieces\n// uses ts event handling no libraries needed\nfunction dragPieceElement(element) {\n    var initialSquare;\n    var initialPos;\n    if (!element) {\n        // error here \n        console.error(`Unable to retrieve element <${element}>`);\n        return;\n    }\n    element.onmousedown = startDrag;\n    function setInitialSquare(square) {\n        initialSquare = square;\n    }\n    function setInitialPosition(pos) {\n        initialPos = pos;\n    }\n    // triggered by onmousedown\n    function startDrag(e) {\n        if (!element) {\n            console.error(\"trying to move non existent element\");\n            return;\n        }\n        // cache initial position and square in case needed to return there\n        var elemRect = element.getBoundingClientRect();\n        setInitialPosition([elemRect.left, elemRect.top]);\n        e.preventDefault();\n        document.onmouseup = stopDrag;\n        document.onmousemove = elementDrag;\n        return true;\n    }\n    // triggered when moving\n    function elementDrag(ev) {\n        ev.preventDefault();\n        if (element) {\n            // elemenet midpoint binds to cursor position\n            element.style.top = (ev.clientY - (element.offsetHeight / 2)) + \"px\";\n            element.style.left = (ev.clientX - (element.offsetWidth / 2)) + \"px\";\n            return true;\n        }\n        console.error(\"Element has been clicked dragged and disappeared\");\n        return false;\n    }\n    // triggered by on mouse up\n    function stopDrag(ev) {\n        snapToBoard([ev.clientX, ev.clientY]);\n        document.onmouseup = null;\n        document.onmousemove = null;\n        return true;\n    }\n    // takes position of element relative to the viewport and snaps it to the board element if element is over a valid square \n    function snapToBoard(position) {\n        if (!element) {\n            console.error(\"Unable to find elements in snapToBoard function\");\n            alert(\"something went wrong with the board see console for details\");\n            return;\n        }\n        var square = positionToSquare(position);\n        // check if piece can move there\n        if (!elemCanMove(initialSquare, square)) {\n            // return to intitial space \n            element.style.left = initialPos[0] + \"px\";\n            element.style.top = initialPos[1] + \"px\";\n            return;\n        }\n        // calculate pixel coords to move to\n        position = positionFromSquare(square);\n        element.style.left = position[0] + \"px\";\n        element.style.top = position[1] + \"px\";\n        setInitialPosition(position);\n        setInitialSquare(square);\n    }\n    // validates if an element can move from a valid t  o square to a potentially invalid square\n    function elemCanMove(fromSquare, toSquare) {\n        // TODO do some stuff when game end\n        var res = queryEngineLegalMove(fromSquare, toSquare);\n        if (res == 0) {\n            console.error(\"Engine error\");\n            return false;\n        }\n        // validate toSquare is on the board \n        var outBoardSquare = toSquare[0] >= BOARDDIMENSION || toSquare[0] < 0 || toSquare[1] >= BOARDDIMENSION || toSquare[1] < 0;\n        var inCorners = toSquare[0] < 3 && (toSquare[1] < 3 || toSquare[1] > 10) ||\n            toSquare[0] > 10 && (toSquare[1] < 3 || toSquare[1] > 10);\n        if (outBoardSquare || inCorners || res < 2) {\n            return false;\n        }\n        return true;\n    }\n}\nfunction queryEngineLegalMove(fromSquare, toSquare) {\n    const url = \"localhost:42069\";\n    const socket = new WebSocket(url);\n    var res = -1;\n    socket.onopen = function (e) {\n        console.log(\"connection established\");\n        socket.send(`${fromSquare[0]}0${fromSquare[1]}0${toSquare[0]}0${toSquare}`);\n    };\n    socket.onmessage = function (e) {\n        res = parseEngineLegalMoveData(e.data);\n    };\n    socket.onclose = function (e) {\n        if (e.wasClean) {\n            console.log(\"Connection closed cleanly\");\n        }\n        else {\n            console.log(\"Connection ended dirty\");\n        }\n    };\n    // hang while waiting for a response\n    while (socket.OPEN && res == -1) {\n        continue;\n    }\n    return res;\n}\n// returns code depending on game state after move\n// 0 - engine error\n// 1 - illegal move\n// 2 - legal move + game cont\n// 3 - legal move + stalemate\n// 4 - legal move + red win\n// 5 - legal move + blue win\n// 6 - legal move + green win       \n// 8 - legal move + yellow win\nfunction parseEngineLegalMoveData(data) {\n    // TODO implemnet when engine and sockets done\n    return 1;\n}\n// takes position of the element relative to viewport\nfunction positionToSquare(position) {\n    //TODO optimise this function to use global variables instead of recalculating\n    var boardElement = document.getElementById(\"boardImage\");\n    if (!boardElement) {\n        console.error(\"unable to find board element\");\n        return [-1, -1];\n    }\n    var boardRect = boardElement.getBoundingClientRect();\n    const squareLength = (boardRect.right - boardRect.left) / BOARDDIMENSION;\n    // make position relative to board\n    position[0] -= boardRect.left;\n    position[1] -= boardRect.top;\n    // remove position relative to the square \n    var square = [-1, -1];\n    square[0] = Math.floor(position[0] / squareLength);\n    square[1] = Math.floor(position[1] / squareLength);\n    return square;\n}\n// returns psoition relative to viewport\nfunction positionFromSquare(square) {\n    //TODO optimise this function to use global variables instead of recalculating\n    var boardElement = document.getElementById(\"boardImage\");\n    if (!boardElement) {\n        console.error(\"unable to find board element\");\n        return [-1, -1];\n    }\n    var boardRect = boardElement.getBoundingClientRect();\n    const squareLength = (boardRect.right - boardRect.left) / BOARDDIMENSION;\n    var position = [-1, -1];\n    position[0] = boardRect.left + square[0] * squareLength;\n    position[1] = boardRect.top + square[1] * squareLength;\n    return position;\n}\n// assume we have <div class=\"piece-br\"></div>\nfunction initBoard() {\n    const pieceClassNames = [\"bb\", \"bk\", \"bn\", \"bp\", \"bq\", \"br\", \"gb\", \"gk\", \"gn\", \"gp\", \"gq\", \"gr\", \"rb\", \"rk\", \"rn\", \"rp\", \"rq\", \"rr\", \"yb\", \"yk\", \"yn\", \"yp\", \"yq\", \"yr\"];\n    // const pieceClassNames = [\"bb\"]; DEBUG CODE\n    for (var i = 0; i < pieceClassNames.length; i++) {\n        var pieceName = pieceClassNames[i];\n        // gets indices of leftmost and downmost piece\n        assignPieces(pieceName);\n    }\n}\nfunction calculatePieceColumn(pieceName) {\n    switch (pieceName[0]) {\n        case 'b': {\n            if (pieceName[1] == 'p') {\n                return 1;\n            }\n            return 0;\n        }\n        case 'g': {\n            if (pieceName[1] == 'p') {\n                return 12;\n            }\n            return 13;\n        }\n        case 'y': {\n            switch (pieceName[1]) {\n                case 'k': {\n                    return 7;\n                }\n                case 'q': {\n                    return 6;\n                }\n                case 'b': {\n                    return 5;\n                }\n                case 'n': {\n                    return 4;\n                }\n                default: {\n                    return 3;\n                }\n            }\n        }\n        default: {\n            switch (pieceName[1]) {\n                case 'k': {\n                    return 7;\n                }\n                case 'q': {\n                    return 6;\n                }\n                case 'b': {\n                    return 5;\n                }\n                case 'n': {\n                    return 4;\n                }\n                default: {\n                    return 3;\n                }\n            }\n        }\n    }\n}\nfunction calculatePieceRow(pieceName) {\n    switch (pieceName[0]) {\n        case 'y': {\n            if (pieceName[1] == 'p') {\n                return 1;\n            }\n            return 0;\n        }\n        case 'r': {\n            if (pieceName[1] == 'p') {\n                return 12;\n            }\n            return 13;\n        }\n        case 'b': {\n            switch (pieceName[1]) {\n                case 'k': {\n                    return 7;\n                }\n                case 'q': {\n                    return 6;\n                }\n                case 'b': {\n                    return 5;\n                }\n                case 'n': {\n                    return 4;\n                }\n                default: {\n                    return 3;\n                }\n            }\n        }\n        default: {\n            switch (pieceName[1]) {\n                case 'k': {\n                    return 7;\n                }\n                case 'q': {\n                    return 6;\n                }\n                case 'b': {\n                    return 5;\n                }\n                case 'n': {\n                    return 4;\n                }\n                default: {\n                    return 3;\n                }\n            }\n        }\n    }\n}\nfunction assignPieces(pieceName) {\n    var container = document.getElementById(\"pieceContainer\");\n    if (!container) {\n        console.error(\"contaienr not found\");\n        return;\n    }\n    // calculate indices according to piece name eg: \"bb\" = blue bishop \n    var initCol = calculatePieceColumn(pieceName);\n    var initRow = calculatePieceRow(pieceName);\n    var position;\n    var pieces = container.getElementsByClassName(\"piece-\" + pieceName);\n    var pieceCount = pieces.length;\n    // for piece duplication\n    // take initial position adding row or col offset\n    var offset = -1;\n    switch (pieceName[1]) {\n        case 'p': {\n            offset = 1;\n            break;\n        }\n        case 'r': {\n            offset = 7;\n            break;\n        }\n        case 'n': {\n            offset = 5;\n            break;\n        }\n        default: {\n            offset = 3;\n            break;\n        }\n    }\n    ;\n    for (var i = 0; i < pieceCount; i++) {\n        var element = pieces[i];\n        dragPieceElement(element);\n        // adding offset is orthogonal between ry and bg pieces\n        // hence we want to choose whether to increment columns or rows\n        if (pieceName[0] == 'r' || pieceName[0] == 'y') {\n            position = positionFromSquare([initCol + (i * offset), initRow]);\n        }\n        else {\n            position = positionFromSquare([initCol, initRow + (i * offset)]);\n        }\n        element.style.left = position[0] + \"px\";\n        element.style.top = position[1] + \"px\";\n    }\n}\n\n\n//# sourceURL=webpack://4pchess/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"](0, __webpack_exports__);
/******/ 	
/******/ })()
;